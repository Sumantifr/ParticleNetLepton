// user include files
#include "NTuplizer_PNLepton.h"
 
//
// member functions
//

// ------------ method called for each event  ------------
void
PNLepton::analyze(const edm::Event& iEvent, const edm::EventSetup& pset) {
  
  using namespace edm;
  Nevt++;
  
  irun = iEvent.id().run();
  ilumi = iEvent.luminosityBlock();
  ievt = iEvent.id().event();
  
  if (Nevt%100==1)cout <<"PNLepton::analyze "<<Nevt<<" "<<iEvent.id().run()<<" "<<iEvent.id().event()<<endl;
    
  // First store all MC information //
    
  if(isMC){
	
	// MC weights //
	  
    edm::Handle<GenEventInfoProduct>eventinfo ;  
    iEvent.getByToken(tok_wt_,eventinfo) ;
        
    if (eventinfo.isValid()){	Generator_weight = eventinfo->weight();  }
    else {  Generator_weight =  -10000;  }
   
    // Gen particles //
    
    edm::Handle<std::vector<reco::GenParticle>> genparticles;  
	iEvent.getByToken(tok_genparticles_,genparticles);
    
    GenPartons.clear();
    
	if(genparticles.isValid()){
	
		for(unsigned ig=0; ig<(genparticles->size()); ig++){
			
			if(!(((*genparticles)[ig].status()==1)||(abs((*genparticles)[ig].status())==22)||((*genparticles)[ig].status()==23))) continue;
				  
			//if(!((abs((*genparticles)[ig].pdgId())>=1 && abs((*genparticles)[ig].pdgId())<=6) || (abs((*genparticles)[ig].pdgId())>=11 && abs((*genparticles)[ig].pdgId())<=16) || (abs((*genparticles)[ig].pdgId())>=21 && abs((*genparticles)[ig].pdgId())<=25))) continue;
			if(!(abs((*genparticles)[ig].pdgId())==11 || abs((*genparticles)[ig].pdgId())==13 || abs((*genparticles)[ig].pdgId())==15) ) continue;
			// important condition on pdg id -> May be changed in other analyses //
	  
			GenParton parton; 
	  
			parton.pt = (*genparticles)[ig].pt();
			parton.eta = (*genparticles)[ig].eta();
			parton.phi = (*genparticles)[ig].phi();
			parton.mass = (*genparticles)[ig].mass();
			parton.p4.SetPtEtaPhiM(parton.pt,parton.eta,parton.phi,parton.mass);
    
			parton.status = (*genparticles)[ig].status();
			parton.pdgId = (*genparticles)[ig].pdgId();
	
			parton.fromhard = (*genparticles)[ig].isHardProcess();
			parton.fromhardbFSR = (*genparticles)[ig].fromHardProcessBeforeFSR();
			parton.isPromptFinalState = (*genparticles)[ig].isPromptFinalState();
			parton.isLastCopyBeforeFSR = (*genparticles)[ig].isLastCopyBeforeFSR();
			parton.isDirectPromptTauDecayProductFinalState = (*genparticles)[ig].isDirectPromptTauDecayProductFinalState();
		
			int mompdg, momstatus, grmompdg;
			mompdg = momstatus = grmompdg = 0;
			
			if((*genparticles)[ig].numberOfMothers()>0){
				
				// mother pdg id & status //
			
				const Candidate * mom = (*genparticles)[ig].mother();
				
				while(mom->pdgId() == (*genparticles)[ig].pdgId())
				{
					mom = mom->mother();
				}
				
				if(!(*genparticles)[ig].isPromptFinalState() && !(*genparticles)[ig].isDirectPromptTauDecayProductFinalState()){
					while(mom->status()==2){
						mom = mom->mother();	
					}
				}
				
				mompdg = mom->pdgId();
				momstatus = mom->status();
	  
				// grand-mother pdg id //
						
				if(mom->numberOfMothers()>0){
	
					const Candidate * grmom = mom->mother();
					
					while(grmom->pdgId() == mompdg)
					{
						if(grmom->numberOfMothers()>0){
							grmom = grmom->mother();
						}
						else{ break; }
					}
					
					grmompdg  = grmom->pdgId();	
				} 
				
			}
			
			parton.mompdgId = mompdg;
			parton.momstatus = momstatus;
			parton.grmompdgId = grmompdg; 
					
			GenPartons.push_back(parton);
    
			if(int(GenPartons.size())>=npartmx) break;
	
		}
    }
    
    GenPart_pt.clear(); GenPart_eta.clear(); GenPart_phi.clear(); GenPart_mass.clear(); 
    GenPart_pdgId.clear(); GenPart_mompdgId.clear(); GenPart_grmompdgId.clear(); 
    
    nGenPart = (int)(GenPartons.size());
    
    for(unsigned igen=0; igen<(GenPartons.size()); igen++){
		
		GenPart_pt.push_back(GenPartons[igen].pt);
		GenPart_eta.push_back(GenPartons[igen].eta);
		GenPart_phi.push_back(GenPartons[igen].phi);
		GenPart_mass.push_back(GenPartons[igen].mass);
		GenPart_pdgId.push_back(GenPartons[igen].pdgId);
		GenPart_mompdgId.push_back(GenPartons[igen].mompdgId);
		GenPart_grmompdgId.push_back(GenPartons[igen].grmompdgId);
		
	}
    
    // Pileup information //
    
    Pileup_nPU = 0;
	Pileup_nTrueInt = 0;
    
    edm::Handle<std::vector<PileupSummaryInfo> > PupInfo;
    iEvent.getByToken(pileup_, PupInfo);
    if (PupInfo.isValid()) {
      std::vector<PileupSummaryInfo>::const_iterator PVI;
      for(PVI = PupInfo->begin(); PVI != PupInfo->end(); ++PVI) {
		if (PVI->getBunchCrossing()==0) {
			Pileup_nPU = PVI->getPU_NumInteractions();
			Pileup_nTrueInt = PVI->getTrueNumInteractions();
			break;
			}
		}
    }

  }//isMC
  
  // Primary vertex info //
  
  Handle<VertexCollection> primaryVertices;
  iEvent.getByToken(tok_primaryVertices_, primaryVertices);
  reco::Vertex PV_vertex;
  
  if (primaryVertices.isValid()) {
	  
	if(primaryVertices->size() > 0){  
		PV_vertex = primaryVertices->at(0); 
	} 

    int nprimi_org = 0;
    
    for (reco::VertexCollection::const_iterator vert=primaryVertices->begin(); vert<primaryVertices->end(); vert++) {
      if (vert->isValid() && !vert->isFake()) {
		if (vert->ndof() > 4 && fabs(vert->position().z()) <= 24 && fabs(vert->position().Rho()) <= 2) {
			nprimi_org++;
			}
		}
    }
   
    PV_npvsGood = nprimi_org;
    
  } else { 
    PV_npvsGood = -100;
  }
  
  // Energy density info //

  edm::Handle<double> Rho_PF;
  iEvent.getByToken(tok_Rho_,Rho_PF);
  Rho = *Rho_PF;

  
  // ====== RECO-objects now  ==========//
  
  edm::Handle<edm::View<pat::PackedCandidate>> pfcands;                                                                                                          
  iEvent.getByToken(tok_pfcands_, pfcands);      
  
  edm::Handle<reco::VertexCompositePtrCandidateCollection> secondaryVertices;
  iEvent.getByToken(tok_sv,secondaryVertices);
                                                                                                         
  
  edm::Handle<edm::View<pat::Muon>> muons;                                                                                                          
  iEvent.getByToken(tok_muons_, muons);       
  
  edm::Handle<edm::View<pat::Jet>> pfjetAK4s;
  iEvent.getByToken(tok_pfjetAK4s_, pfjetAK4s);                                                                                   
  
  std::vector<TLorentzVector> tlep;
  
  // Muons //
    
  nLepton = 0; 
  
  vector<Lepton> leptons;    
  
  if(save_only_muons){  
                                                                                                                                   
	if(muons.isValid() && muons->size()>0) {                                                                                                           
    
		edm::View<pat::Muon>::const_iterator muon1;                                                                                                      

		for( muon1 = muons->begin(); muon1 < muons->end(); muon1++ ) {                                                                                   

			if (StoreMuon(*muon1,minmuPt,maxEta)) {
			
				Lepton lepton;  
				Initialize(lepton);                                                              
			
				TrackRef trktrk = muon1->innerTrack();   
			
				lepton.pt = muon1->pt();                                                                                                                                                                             
				lepton.p = trktrk->p();                                                                                                          
				lepton.eta = muon1->eta();                                                                                                              
				lepton.phi = muon1->phi();  
				lepton.mass = muon1->mass();  
				lepton.charge = muon1->charge();                                                                                                                                                                                                                          
				lepton.pdgId = muon1->pdgId();
				lepton.tightcharge = (muon1->muonBestTrack()->ptError()/muon1->muonBestTrack()->pt() < 0.2)?2:0;
                                                                                                                                                       
				//MiniIsolation //     
			                                                                                 
				vector<float> isovalues;
				Read_MiniIsolation(muon1,Rho,isovalues);
				lepton.minisoall = isovalues[0];
				lepton.minchiso = isovalues[1];
				lepton.minnhiso = isovalues[2];
				lepton.minphiso = isovalues[3];
			                                         
				// Basic id variables //    
			                                  
				lepton.isPFCand = muon1->isPFMuon();                                                                                                        
				lepton.isGlobal = muon1->isGlobalMuon();                                                                                                    
				lepton.isTracker = muon1->isTrackerMuon();                                                                                                  
				lepton.isLoose = (muon::isLooseMuon(*muon1));                                                                                           
				lepton.isMedium = (muon::isMediumMuon(*muon1));                                                                                            
				lepton.isMedPr = false;                                                                          
				if(muon::isMediumMuon(*muon1)) {                                                                                                             
					if ((std::abs(muon1->muonBestTrack()->dz(PV_vertex.position())) < 0.1) && (std::abs(muon1->muonBestTrack()->dxy(PV_vertex.position())) < 0.02)){                                                                                                                  
						lepton.isMedPr = true;                                                                                                              
					}                                                                                                                                          
				}                                                                                                                                      
				lepton.isGoodGlobal = (muon1->isGlobalMuon() && muon1->globalTrack()->normalizedChi2() < 3 && muon1->combinedQuality().chi2LocalPosition < 12 && muon1->combinedQuality().trkKink < 20 && (muon::segmentCompatibility(*muon1)) > 0.303);                     
				lepton.isTight = (muon::isTightMuon(*muon1,PV_vertex));                                                                                    
				lepton.isHighPt = (muon::isHighPtMuon(*muon1,PV_vertex));                                                                                  
				lepton.isHighPttrk = (muon::isTrackerHighPtMuon(*muon1,PV_vertex));   
			
				// Displacement //
			
				lepton.dxy = muon1->muonBestTrack()->dxy(PV_vertex.position());                                                                         
				lepton.dz = muon1->muonBestTrack()->dz(PV_vertex.position());  
				lepton.dxyError = muon1->edB(pat::Muon::PV2D);   
				lepton.dzError = muon1->edB(pat::Muon::PVDZ);   
				lepton.dxySig = lepton.dxy*1./TMath::Max(float(1.e-6),float(lepton.dxyError));
				lepton.dzSig = lepton.dz*1./TMath::Max(float(1.e-6),float(lepton.dzError));
				lepton.ip3d =  muon1->dB(pat::Muon::PV3D);    
				lepton.sip3d =  muon1->dB(pat::Muon::PV3D)/muon1->edB(pat::Muon::PV3D);     
			
				// Displacement w.r.t secondary vertex //
			 
				lepton.dxy_sv = DistanceFromSV_Muon(muon1->muonBestTrack(),secondaryVertices);  
			
				// GEN particle matching //
			
				if(isMC){
					lepton.genPartIdx  = getGenPartonIndex(lepton.eta,lepton.phi,GenPartons,13);
					lepton.genPartFlav = getGenPartonFlavor(GenPartons,lepton.genPartIdx);
				}else{
					lepton.genPartIdx = -1;
					lepton.genPartFlav = 0;
				}
    
				// Energy info //
			                                                   
				lepton.e_ECAL = (muon1->calEnergy()).em * 1./muon1->energy();                                                                                                  
				lepton.e_HCAL = (muon1->calEnergy()).had* 1./muon1->energy();
				lepton.hoe = lepton.e_HCAL*1./TMath::Max(float(1.e-6),float(lepton.e_ECAL));
			
				// Track info //
			                                                                         
				lepton.posmatch = muon1->combinedQuality().chi2LocalPosition;                                                                           
				lepton.trkKink = muon1->combinedQuality().trkKink;                                                                                       
				lepton.segmentComp = muon::segmentCompatibility(*muon1);                                                                                     
			                                                                                                                                                                                                            
				TrackRef trkglb =muon1->globalTrack();                                                                                                       
				if ((!muon1->isGlobalMuon())) {                                                                                                              
					if (muon1->isTrackerMuon()) {                                                                                                              
						trkglb =muon1->innerTrack();                                                                                                             
					} else {                                                                                                                                   
						trkglb =muon1->outerTrack();                                                                                                             
					}                                                                                                                                          
				}
			                                                                                                                                            
				lepton.chi2 = trkglb->normalizedChi2();                                                                                                  
				lepton.ndof = (int)trkglb->ndof();                                                                                                       
				lepton.hit = (int)trkglb->hitPattern().numberOfValidMuonHits();                                                                              
				lepton.nStations = (int)muon1->numberOfMatchedStations();                                                                                          
				lepton.pixhit = (int)trktrk->hitPattern().numberOfValidPixelHits();                                                                          
				lepton.nTrackerLayers = (int)trktrk->hitPattern().trackerLayersWithMeasurement();                                                                    
				lepton.valfrac = trktrk->validFraction();   
				lepton.lostHits = (int)trktrk->hitPattern().numberOfLostHits(reco::HitPattern::MISSING_INNER_HITS); 
			
				// Isolation variables //
			                                                    
				lepton.pfRelIso04_drcor = (muon1->pfIsolationR04().sumChargedHadronPt + max(0., muon1->pfIsolationR04().sumNeutralHadronEt + muon1->pfIsolationR04().sumPhotonEt - 0.5*muon1->pfIsolationR04().sumPUPt))/muon1->pt();                                               
				lepton.pfRelIso04_ChargedHadron = muon1->pfIsolationR04().sumChargedHadronPt*1./muon1->pt();     
				lepton.pfRelIso04_NeutralHadron = muon1->pfIsolationR04().sumNeutralHadronEt*1./muon1->pt();     
				lepton.pfRelIso04_Photon = muon1->pfIsolationR04().sumPhotonEt*1./muon1->pt();     
				lepton.pfRelIso04_PileUp = muon1->pfIsolationR04().sumPUPt*1./muon1->pt();   
			
				lepton.pfRelIso03_drcor = (muon1->pfIsolationR03().sumChargedHadronPt + max(0., muon1->pfIsolationR03().sumNeutralHadronEt + muon1->pfIsolationR03().sumPhotonEt - 0.5*muon1->pfIsolationR03().sumPUPt))/muon1->pt();                                               
				lepton.pfRelIso03_ChargedHadron = muon1->pfIsolationR03().sumChargedHadronPt*1./muon1->pt();     
				lepton.pfRelIso03_NeutralHadron = muon1->pfIsolationR03().sumNeutralHadronEt*1./muon1->pt();     
				lepton.pfRelIso03_Photon = muon1->pfIsolationR03().sumPhotonEt*1./muon1->pt();     
				lepton.pfRelIso03_PileUp = muon1->pfIsolationR03().sumPUPt*1./muon1->pt();  
				lepton.tkRelIso = muon1->isolationR03().sumPt/muon1->tunePMuonBestTrack()->pt();
				
				// store 4-vector to vector of leptons //
				TLorentzVector p4;
				p4.SetPtEtaPhiM(lepton.pt, lepton.eta, lepton.phi, lepton.mass);
				tlep.push_back(p4);
				
				lepton.MuonPtr = (*muon1);
			
				// now push lepton to vector of leptons //
				leptons.push_back(lepton);
			
				if (++nLepton>=njetmx) break;                                                                                                                 
		
			}                                                                                                                                              
		}                                                                                                                                               
	}// muon loop 
  }//save_only_muons
  
  // Electrons //
  
  if(save_only_electrons){
  
	for(const auto& electron1 : iEvent.get(tok_electrons_) ) {                                                                                          
 
		if (!StoreElectron(electron1,minePt,maxEta)) continue;
                    
		Lepton lepton;
		Initialize(lepton);                     
                                                   
		GsfTrackRef gsftrk1 = electron1.gsfTrack();   																														
		TrackRef ctftrk = electron1.closestCtfTrackRef();    
    
		// Basic kinematic variables //
    
		lepton.pt = electron1.pt();   	                                                                                 
		lepton.eta = electron1.eta();                                                                                                                 
		lepton.phi = electron1.phi();                                                                                                                 
		lepton.mass = electron1.mass();                                                                                              
		lepton.p = electron1.trackMomentumAtVtx().R();
		lepton.charge = electron1.charge();     
		lepton.pdgId = electron1.pdgId(); 
		lepton.tightcharge = electron1.isGsfCtfScPixChargeConsistent() + electron1.isGsfScPixChargeConsistent();
    
		// Energy variables //
    
		lepton.e_ECAL = electron1.ecalEnergy()*1./electron1.energy();   
		lepton.e_HCAL = 1.-lepton.e_ECAL;  
    
		// MVA id //
    
		lepton.mvaid_Fallv2WP90 = electron1.electronID(melectronID_isowp90);                                                                                 
		lepton.mvaid_Fallv2WP90_noIso = electron1.electronID(melectronID_noisowp90);                                                                             
		lepton.mvaid_Fallv2WP80 = electron1.electronID(melectronID_isowp80);                                                                                 
		lepton.mvaid_Fallv2WP80_noIso = electron1.electronID(melectronID_noisowp80);   
		
		lepton.mvaFall17V1Iso = electron1.userFloat("ElectronMVAEstimatorRun2Fall17IsoV1Values");
		lepton.mvaFall17V1noIso = electron1.userFloat("ElectronMVAEstimatorRun2Fall17NoIsoV1Values");
		lepton.mvaFall17V2Iso = electron1.userFloat("ElectronMVAEstimatorRun2Fall17IsoV2Values");
		lepton.mvaFall17V2noIso = electron1.userFloat("ElectronMVAEstimatorRun2Fall17NoIsoV2Values");
    
		// displacement //
                                                                                 
		lepton.dxy = gsftrk1->dxy(PV_vertex.position());  
		lepton.dxyError = electron1.edB(pat::Electron::PV2D);                                                                                           
		lepton.dz = gsftrk1->dz(PV_vertex.position()); 
		lepton.dzError = electron1.edB(pat::Electron::PVDZ);  
		lepton.dxySig = lepton.dxy*1./TMath::Max(float(1.e-6),float(lepton.dxyError));
		lepton.dzSig = lepton.dz*1./TMath::Max(float(1.e-6),float(lepton.dzError));  
		lepton.ip3d =  electron1.dB(pat::Electron::PV3D); 
		lepton.sip3d =  electron1.dB(pat::Electron::PV3D)/electron1.edB(pat::Electron::PV3D);    
    
    
		// Displacement w.r.t secondary vertex //
                                                                                                                                                
		lepton.dxy_sv = DistanceFromSV_Electron(gsftrk1,secondaryVertices);                                                                                          
    
		// GEN particle matching //
  
		if(isMC){
			lepton.genPartIdx  = getGenPartonIndex(lepton.eta,lepton.phi,GenPartons,11);
			lepton.genPartFlav = getGenPartonFlavor(GenPartons,lepton.genPartIdx);
		}else{
			lepton.genPartIdx = -1;
			lepton.genPartFlav = 0;
		}
      
		// supercluste info //
    
		lepton.supcl_energy = electron1.superCluster()->energy();  
		lepton.supcl_eta = electron1.superCluster()->eta();                                                                                           
		lepton.supcl_phi = electron1.superCluster()->phi();                                                                                           
    
		// shape of energy deposition //             
                                                                                                                                                                                                                                              
		lepton.sigmaietaieta = electron1.full5x5_sigmaIetaIeta();                                                                                         
		lepton.sigmaiphiiphi = electron1.full5x5_sigmaIphiIphi();  
		lepton.hcaloverecal = electron1.full5x5_hcalOverEcal();                                                                                         
		lepton.r9full = electron1.full5x5_r9(); 
		lepton.e1x5bye5x5 = 1.-electron1.full5x5_e1x5()/electron1.full5x5_e5x5();   
                                                                                                                                                                                                                                                  
		lepton.eoverp = 1./electron1.superCluster()->energy();                                                                                             
		lepton.hoe = electron1.hadronicOverEm();                                                                                                   
		lepton.ecloverpout = electron1.eEleClusterOverPout();  
		lepton.convVeto = electron1.passConversionVeto();
    
		lepton.eInvMinusPInv =  (1-electron1.eSuperClusterOverP())/electron1.ecalEnergy(); // OR 1.0/(electron1.ecalEnergy())-1.0/(electron1.trackMomentumAtVtx().R())
		lepton.etain = electron1.deltaEtaSuperClusterTrackAtVtx();  
		if(electron1.superCluster()->seed().isNonnull()){
			lepton.dEtaInSeed = electron1.deltaEtaSuperClusterTrackAtVtx() - electron1.superCluster()->eta() + electron1.superCluster()->seed()->eta();  
		}                                                                               
		lepton.phiin = electron1.deltaPhiSuperClusterTrackAtVtx();                                                                                     
		lepton.supcl_preshvsrawe = electron1.superCluster()->preshowerEnergy()/electron1.superCluster()->rawEnergy();                                                                                                                                            
		lepton.supcl_etaWidth = electron1.superCluster()->etaWidth();                                                                                     
		lepton.supcl_phiWidth = electron1.superCluster()->phiWidth(); 
		lepton.deltaetacltrkcalo = electron1.deltaEtaSeedClusterTrackAtCalo();   
	                                                                                                        
		lepton.convtxprob = electron1.convVtxFitProb();   
		lepton.fbrem = electron1.fbrem();                         
	                                                                 
		// isolation variables //                              
                                                                                                                                                                                       
		const reco::GsfElectron::PflowIsolationVariables& pfIso = electron1.pfIsolationVariables();  
		lepton.pfRelIso03_ChargedHadron = pfIso.sumChargedHadronPt*1./electron1.pt();                                                                
		lepton.pfRelIso03_NeutralHadron = pfIso.sumNeutralHadronEt*1./electron1.pt(); 
		lepton.pfRelIso03_Photon = pfIso.sumPhotonEt*1./electron1.pt();                                                                                                                         
		lepton.pfRelIso03_drcor = (pfIso.sumChargedHadronPt + max(0., pfIso.sumNeutralHadronEt + pfIso.sumPhotonEt - 0.5*pfIso.sumPUPt))*1./electron1.pt();   
  
		lepton.dr03EcalRecHitSumEt_Rel = (electron1.pt()>35.)?(electron1.dr03EcalRecHitSumEt()*1./electron1.pt()):-100; 
		lepton.dr03HcalDepth1TowerSumEt_Rel = (electron1.pt()>35.)?(electron1.dr03HcalDepth1TowerSumEt()*1./electron1.pt()):-100; 
		lepton.dr03HcalDepth2TowerSumEt_Rel = (electron1.pt()>35.)?(electron1.dr03HcalDepth2TowerSumEt()*1./electron1.pt()):-100;
		lepton.dr03TkSumPt_Rel =  (electron1.pt()>35.)?(electron1.dr03TkSumPt()*1./electron1.pt()):-100;
		lepton.dr03TkSumPtHEEP_Rel =  (electron1.pt()>35.)?(electron1.dr03TkSumPtHEEP()*1./electron1.pt()):-100;
    
		//const reco::GsfElectron::PflowIsolationVariables& PfIso = electron1.isolationVariables04();//dr04IsolationVariables(); //pfIsolationVariables();  
		//lepton.pfRelIso04_ChargedHadron = PfIso.sumChargedHadronPt*1./electron1.pt();                                                                
		//lepton.pfRelIso04_NeutralHadron = PfIso.sumNeutralHadronEt*1./electron1.pt(); 
		//lepton.pfRelIso04_Photon = PfIso.sumPhotonEt*1./electron1.pt();                                                                                                                         
		//lepton.pfRelIso04_drcor = (PfIso.sumChargedHadronPt + max(0., PfIso.sumNeutralHadronEt + PfIso.sumPhotonEt - 0.5*PfIso.sumPUPt))*1./electron1.pt();   
    
		vector<float> pfisovalues;                                                                                     
		Read_ElePFIsolation(&electron1,Rho,pfisovalues);
		lepton.pfRelIso03_eacor = pfisovalues[0];
		lepton.pfRelIso04_eacor = pfisovalues[1];
    
		//MiniIsolation//                                                                                      
	
		vector<float> isovalues;
		Read_MiniIsolation(&electron1,Rho,isovalues);
		lepton.minisoall = isovalues[0];
		lepton.minchiso = isovalues[1];
		lepton.minnhiso = isovalues[2];
		lepton.minphiso = isovalues[3];
		
		// track info //
    
		lepton.chi2 = gsftrk1->normalizedChi2();                                                                                                                 
		lepton.ndof = (int)gsftrk1->ndof();                                                                                                            
		lepton.lostHits = (int)gsftrk1->hitPattern().numberOfLostHits(reco::HitPattern::MISSING_INNER_HITS);
		lepton.hit = (int)gsftrk1->hitPattern().numberOfValidMuonHits();                                                                              
		//lepton.nStations = (int)gsftrk1->numberOfMatchedStations();                                                                                          
		lepton.pixhit = (int)gsftrk1->hitPattern().numberOfValidPixelHits();                                                                          
		lepton.nTrackerLayers = (int)gsftrk1->hitPattern().trackerLayersWithMeasurement();                                                                    
		lepton.valfrac = gsftrk1->validFraction();   
		lepton.closeTrackNLayers = (int)electron1.closestCtfTrackNLayers();      
		lepton.closeTrackNormChi2 = electron1.closestCtfTrackNormChi2();   
	
		// store 4-vector to vector of leptons //
		TLorentzVector p4;
		p4.SetPtEtaPhiM(lepton.pt, lepton.eta, lepton.phi, lepton.mass);
		tlep.push_back(p4);
		
		lepton.ElectronPtr = electron1;
	
		// now push lepton to vector of leptons //
		leptons.push_back(lepton);
	
		if(++nLepton>=njetmx) break;      
		                                                                                                                
	}// loop over electrons
  
  }//save_only_electrons
  
 // AK4 Jet //
  
  nPFJetAK4 = 0;
  
  for (unsigned jet = 0; jet< pfjetAK4s->size(); jet++) {
      
	const auto &ak4jet = (*pfjetAK4s)[jet];
    TLorentzVector pfjetAK4_4v(ak4jet.correctedP4("Uncorrected").px(),ak4jet.correctedP4("Uncorrected").py(),ak4jet.correctedP4("Uncorrected").pz(), ak4jet.correctedP4("Uncorrected").energy());
  
    if(pfjetAK4_4v.Pt()<minjPt) continue;
    if(abs(pfjetAK4_4v.Rapidity())>maxEta) continue;
      
    PFJetAK4_pt[nPFJetAK4] = 	pfjetAK4_4v.Pt();
    PFJetAK4_eta[nPFJetAK4] = 	pfjetAK4_4v.Eta();
    PFJetAK4_y[nPFJetAK4] = pfjetAK4_4v.Rapidity();
    PFJetAK4_phi[nPFJetAK4] = pfjetAK4_4v.Phi();
    PFJetAK4_mass[nPFJetAK4] = pfjetAK4_4v.M(); 
    
    // Jet id //
      
    JetIDVars AK4idvars;
      
    AK4idvars.NHF = ak4jet.neutralHadronEnergyFraction();
    AK4idvars.NEMF = ak4jet.neutralEmEnergyFraction();
    AK4idvars.MUF = ak4jet.muonEnergyFraction();
    AK4idvars.CHF = ak4jet.chargedHadronEnergyFraction();
    AK4idvars.CEMF = ak4jet.chargedEmEnergyFraction();
    AK4idvars.NumConst = (ak4jet.chargedMultiplicity()+ak4jet.neutralMultiplicity());
    AK4idvars.NumNeutralParticle = ak4jet.neutralMultiplicity();
    AK4idvars.CHM = ak4jet.chargedHadronMultiplicity();
     
    PFJetAK4_jetID[nPFJetAK4] = getJetID(AK4idvars,"CHS",year,PFJetAK4_eta[nPFJetAK4],false,isUltraLegacy);
    PFJetAK4_jetID_tightlepveto[nPFJetAK4] = getJetID(AK4idvars,"CHS",year,PFJetAK4_eta[nPFJetAK4],true,isUltraLegacy);
      
    PFJetAK4_qgl[nPFJetAK4] = ak4jet.userFloat("QGTagger:qgLikelihood");
    PFJetAK4_PUID[nPFJetAK4] = ak4jet.userFloat("pileupJetId:fullDiscriminant");
        
    // B tagging stuffs //
    
    PFJetAK4_btag_DeepCSV[nPFJetAK4] = ak4jet.bDiscriminator("pfDeepCSVJetTags:probb")+ak4jet.bDiscriminator("pfDeepCSVJetTags:probbb");
    PFJetAK4_btag_DeepFlav[nPFJetAK4] = ak4jet.bDiscriminator("pfDeepFlavourJetTags:probb") + ak4jet.bDiscriminator("pfDeepFlavourJetTags:probbb")+ak4jet.bDiscriminator("pfDeepFlavourJetTags:problepb");
    
    // store jet index in collection //
    
    PFJetAK4_index[nPFJetAK4] = jet;
     
    nPFJetAK4++;	
    if(nPFJetAK4 >= njetmx) { break;}
    
  }
   
  // Skimming condition //
  
  if((nLepton)>=1){
	  
	for(unsigned ilep=0; ilep<leptons.size(); ilep++){
	
		if(save_only_muons) { 
			if (abs(leptons[ilep].pdgId)!=13) continue;
		}
		else if(save_only_electrons) { 
			if (abs(leptons[ilep].pdgId)!=11) continue;
		}
	
		lepton_genPartFlav = leptons[ilep].genPartFlav;
		
		// create generator labels //
		
		label_Muon_Prompt = label_Muon_fromTau = label_Muon_fromHFHadron = label_Muon_fromLFHadron = label_Muon_fromPhoton = label_Muon_unknown = label_Muon_fromPhotonORunknown = 0;
		label_Electron_Prompt = label_Electron_fromTau = label_Electron_fromHFHadron = label_Electron_fromLFHadron = label_Electron_fromPhoton = label_Electron_unknown = label_Electron_fromPhotonORunknown = 0;
		label_unknown = 0;
		
		if(abs(leptons[ilep].pdgId)==13){
			label_Muon = true;
			if(leptons[ilep].genPartFlav==1) { label_Muon_Prompt = 1; }
			else if (leptons[ilep].genPartFlav==15) { label_Muon_fromTau = 1; }
			else if (leptons[ilep].genPartFlav==22) { label_Muon_fromPhoton = 1; }
			else if (leptons[ilep].genPartFlav==5 || leptons[ilep].genPartFlav==4) { label_Muon_fromHFHadron = 1; }
			else if (leptons[ilep].genPartFlav==3) { label_Muon_fromLFHadron = 1; }
			else { label_Muon_unknown = 1; }
		}
		else if(abs(leptons[ilep].pdgId)==11){
			label_Electron = true;
			if(leptons[ilep].genPartFlav==1) { label_Electron_Prompt = 1; }
			else if (leptons[ilep].genPartFlav==15) { label_Electron_fromTau = 1; }
			else if (leptons[ilep].genPartFlav==22) { label_Electron_fromPhoton = 1; }
			else if (leptons[ilep].genPartFlav==5 || leptons[ilep].genPartFlav==4) { label_Electron_fromHFHadron = 1; }
			else if (leptons[ilep].genPartFlav==3) { label_Electron_fromLFHadron = 1; }
			else { label_Electron_unknown = 1; }
		}
		
		if((label_Muon_Prompt+label_Muon_fromTau+label_Muon_fromHFHadron+label_Muon_fromLFHadron+label_Muon_fromPhoton+label_Muon_unknown+label_Electron_Prompt+label_Electron_fromTau+label_Electron_fromHFHadron+label_Electron_fromLFHadron+label_Electron_fromPhoton+label_Electron_unknown)<1){
			label_unknown = 1;
		}
		
		if((label_Muon_fromPhoton+label_Muon_unknown)==1) {  label_Muon_fromPhotonORunknown = 1;  }
		if((label_Electron_fromPhoton+label_Electron_unknown)==1) {  label_Electron_fromPhotonORunknown = 1;  }
		
		if((label_Muon_Prompt+label_Muon_fromTau)==1) { label_Muon_PromptORTau = 1; }
		if((label_Electron_Prompt+label_Electron_fromTau)==1) { label_Electron_PromptORTau = 1; }
		
		label_fromTop = label_fromW = label_fromZ = label_fromH = label_fromNP = false;
		label_fromQCD = label_fromQCD_b = label_fromQCD_c = label_fromQCD_l = label_others = label_noGenMatch = false;
		
		if(leptons[ilep].genPartIdx>=0){
			if(leptons[ilep].genPartFlav==1){
				if((abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==6) || (abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==24 && abs(GenPartons[leptons[ilep].genPartIdx].grmompdgId)==6)) { label_fromTop = true; }
				if((abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==25) || (abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==24 && abs(GenPartons[leptons[ilep].genPartIdx].grmompdgId)==25)) { label_fromH = true; }
				if(abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==24) { label_fromW = true; }
				if(abs(GenPartons[leptons[ilep].genPartIdx].mompdgId)==23) { label_fromZ = true; }
				label_fromNP = (!label_fromTop && !label_fromH && !label_fromW && !label_fromZ);
			}
			else if(leptons[ilep].genPartFlav==5 || leptons[ilep].genPartFlav==4 || leptons[ilep].genPartFlav==3){
				label_fromQCD = true;
				if(leptons[ilep].genPartFlav==5) { label_fromQCD_b = true; }
				else if (leptons[ilep].genPartFlav==4) { label_fromQCD_c = true; }
				else { label_fromQCD_l = true; }
			}
			else { label_others = true; }
		}
		else { label_noGenMatch = true; }
		
		// created generator labels //
	
		lepton_pt = leptons[ilep].pt;
		lepton_eta = leptons[ilep].eta;
		lepton_phi = leptons[ilep].phi;
		lepton_mass = leptons[ilep].mass;		
		lepton_p = leptons[ilep].p ;
	
		lepton_pdgId = leptons[ilep].pdgId;
		lepton_charge = (float)leptons[ilep].charge;
		lepton_tightcharge = (float)leptons[ilep].tightcharge;
		
		lepton_dxy = leptons[ilep].dxy;
		lepton_dz = leptons[ilep].dz;
		lepton_dxyError = leptons[ilep].dxyError;
		lepton_dzError = leptons[ilep].dzError;
		lepton_dxySig = leptons[ilep].dxySig;
		lepton_dzSig = leptons[ilep].dzSig;
		lepton_ip3d = leptons[ilep].ip3d;
		lepton_sip3d = leptons[ilep].sip3d;
		lepton_dxy_sv = leptons[ilep].dxy_sv;
  
		lepton_chi2 = leptons[ilep].chi2;
		lepton_ndof = (float)leptons[ilep].ndof;
		lepton_trkKink = leptons[ilep].trkKink;
		lepton_hit = (float)leptons[ilep].hit;
		lepton_pixhit = (float)leptons[ilep].pixhit;
		lepton_nTrackerLayers = (float)leptons[ilep].nTrackerLayers;
		lepton_lostHits = (float)leptons[ilep].lostHits;
    
		lepton_e_ECAL = leptons[ilep].e_ECAL;
		lepton_e_HCAL = leptons[ilep].e_HCAL;
		lepton_hoe = leptons[ilep].hoe;
		  
		lepton_minchiso = leptons[ilep].minchiso;
		lepton_minnhiso = leptons[ilep].minnhiso;
		lepton_minphiso = leptons[ilep].minphiso;
		lepton_minisoall = leptons[ilep].minisoall;
		
		lepton_pfRelIso03_drcor = leptons[ilep].pfRelIso03_drcor;
		lepton_pfRelIso03_ChargedHadron = leptons[ilep].pfRelIso03_ChargedHadron;
		lepton_pfRelIso03_NeutralHadron = leptons[ilep].pfRelIso03_NeutralHadron;
		lepton_pfRelIso03_Photon = leptons[ilep].pfRelIso03_Photon;
		lepton_pfRelIso03_PileUp = leptons[ilep].pfRelIso03_PileUp;
		lepton_tkRelIso = leptons[ilep].tkRelIso;
		
		if(save_only_muons){
		
			lepton_nStations = (float)leptons[ilep].nStations;
			lepton_segmentComp = leptons[ilep].segmentComp;
			lepton_posmatch = leptons[ilep].posmatch;
    
			lepton_isPFCand = (float)leptons[ilep].isPFCand;
			lepton_isGlobal = (float)leptons[ilep].isGlobal;
			lepton_isTracker = (float)leptons[ilep].isTracker;
			lepton_isLoose = (float)leptons[ilep].isLoose;
			lepton_isGoodGlobal = (float)leptons[ilep].isGoodGlobal;
			lepton_isMedium = (float)leptons[ilep].isMedium;
			lepton_isMedPr = (float)leptons[ilep].isMedPr;
			lepton_isTight = (float)leptons[ilep].isTight;
			lepton_isHighPt = (float)leptons[ilep].isHighPt;
			lepton_isHighPttrk = (float)leptons[ilep].isHighPttrk;
   
		}
		
		if(save_only_electrons){
    
			lepton_mvaid_Fallv2WP90 = leptons[ilep].mvaid_Fallv2WP90;
			lepton_mvaid_Fallv2WP90_noIso = leptons[ilep].mvaid_Fallv2WP90_noIso;
			lepton_mvaid_Fallv2WP80 = leptons[ilep].mvaid_Fallv2WP80;
			lepton_mvaid_Fallv2WP80_noIso = leptons[ilep].mvaid_Fallv2WP80_noIso;
			
			lepton_mvaFall17V1Iso = leptons[ilep].mvaFall17V1Iso;
			lepton_mvaFall17V1noIso = leptons[ilep].mvaFall17V1noIso;
			lepton_mvaFall17V2Iso = leptons[ilep].mvaFall17V2Iso;
			lepton_mvaFall17V2noIso = leptons[ilep].mvaFall17V2noIso;
  
			lepton_eoverp = leptons[ilep].eoverp;
 
			lepton_pfRelIso03_eacor = leptons[ilep].pfRelIso03_eacor ;
			lepton_pfRelIso04_eacor = leptons[ilep].pfRelIso04_eacor;
			lepton_dr03EcalRecHitSumEt_Rel = leptons[ilep].dr03EcalRecHitSumEt_Rel;
			lepton_dr03HcalDepth1TowerSumEt_Rel = leptons[ilep].dr03HcalDepth1TowerSumEt_Rel;
			lepton_dr03HcalDepth2TowerSumEt_Rel = leptons[ilep].dr03HcalDepth2TowerSumEt_Rel;
			lepton_dr03TkSumPt_Rel = leptons[ilep].dr03TkSumPt_Rel;
			lepton_dr03TkSumPtHEEP_Rel = leptons[ilep].dr03TkSumPtHEEP_Rel;
  
			lepton_eInvMinusPInv = leptons[ilep].eInvMinusPInv;
			lepton_supcl_eta = leptons[ilep].supcl_eta;
			lepton_supcl_phi = leptons[ilep].supcl_phi;
			lepton_supcl_energy = leptons[ilep].supcl_energy;
			lepton_sigmaietaieta = leptons[ilep].sigmaietaieta;
			lepton_sigmaiphiiphi = leptons[ilep].sigmaiphiiphi;
			lepton_r9full = leptons[ilep].r9full;
			lepton_hcaloverecal = leptons[ilep].hcaloverecal;
			lepton_ecloverpout = leptons[ilep].ecloverpout;
			lepton_convVeto = (float)leptons[ilep].convVeto;

			lepton_etain = leptons[ilep].etain;
			lepton_dEtaInSeed = leptons[ilep].dEtaInSeed;
			lepton_phiin = leptons[ilep].phiin;
			lepton_fbrem = leptons[ilep].fbrem;
			lepton_supcl_etaWidth = leptons[ilep].supcl_etaWidth;
			lepton_supcl_phiWidth = leptons[ilep].supcl_phiWidth;
  
			lepton_e1x5bye5x5 = leptons[ilep].e1x5bye5x5;
			lepton_convtxprob = leptons[ilep].convtxprob;
			lepton_deltaetacltrkcalo = leptons[ilep].deltaetacltrkcalo;
			lepton_supcl_preshvsrawe = leptons[ilep].supcl_preshvsrawe;
  
			lepton_closeTrackNLayers = (float)leptons[ilep].closeTrackNLayers;
			lepton_closeTrackNormChi2 = leptons[ilep].closeTrackNormChi2;
		
		}
		
		// PF candidates within dR<0.5 around lepton //
		
		nPFCand = 0;  
		
		vector<PFlowCandidate> pfcandidates; 
		
		float dRmin = DR_PFCand_Minimum;                                                                                                                                                                                                                                    
  
		if(pfcands.isValid() && pfcands->size()>0) {                                                                                                           
    
			edm::View<pat::PackedCandidate>::const_iterator pfcand1;     
			
			float dRmax = DR_PFCand_Maximum;  
			
			for( pfcand1 = pfcands->begin(); pfcand1 < pfcands->end(); pfcand1++ ) {    
		
				if(delta2R(leptons[ilep].eta,leptons[ilep].phi,pfcand1->eta(),pfcand1->phi())<dRmax){ // && delta2R(leptons[ilep].eta,leptons[ilep].phi,pfcand1->eta(),pfcand1->phi())>dRmin){
				
					PFlowCandidate pfcand;
					Initialize_PFlowCandidate(pfcand);
		
					pfcand.pt = pfcand1->pt();
					pfcand.eta = pfcand1->eta();
					pfcand.phi = pfcand1->phi();
					pfcand.mass = pfcand1->mass();
					pfcand.phiAtVtx = pfcand1->phiAtVtx();
					pfcand.pdgId = pfcand1->pdgId();
					pfcand.puppiWeight = pfcand1->puppiWeight();
					pfcand.puppiWeightNoLep = pfcand1->puppiWeightNoLep();
		
					pfcand.status = pfcand1->status();
					pfcand.caloFraction = pfcand1->caloFraction();
					
					pfcand.hcalFraction = 0;
					if (pfcand.pdgId == 1 || pfcand.pdgId == 130) {
						pfcand.hcalFraction = pfcand1->hcalFraction();
					} else if (pfcand1->isIsolatedChargedHadron()) {
						pfcand.hcalFraction = pfcand1->rawHcalFraction();
					}

					pfcand.hcalFractionCalib = pfcand1->hcalFraction();
					
					pfcand.isElectron = (pfcand1->isElectron() || abs(pfcand.pdgId)==11);
					pfcand.isMuon = (pfcand1->isMuon() || abs(pfcand.pdgId)==13);
					pfcand.isPhoton = (pfcand1->isPhoton() || abs(pfcand.pdgId)==22);
					pfcand.isChargedHadron = (abs(pfcand.pdgId)==211);
					pfcand.isNeutralHadron = (abs(pfcand.pdgId)==211);
					
					pfcand.hasTrackDetails = pfcand1->hasTrackDetails();
		
					if(pfcand1->hasTrackDetails()){
			
						pfcand.fromPV = pfcand1->fromPV();
						pfcand.time = pfcand1->time();
						pfcand.charge = pfcand1->charge();
						pfcand.dz = pfcand1->dz();
						pfcand.dzError = pfcand1->dzError();
						pfcand.dzSig = pfcand1->dz()*1./TMath::Max(float(pfcand1->dzError()),float(1.e-6));
						pfcand.dxy = pfcand1->dxy();
						pfcand.dxyError = pfcand1->dxyError();
						pfcand.dxySig = pfcand1->dxy()*1./TMath::Max(float(pfcand1->dxyError()),float(1.e-6));
						pfcand.vertexChi2 = pfcand1->vertexChi2();
						pfcand.lostInnerHits = pfcand1->lostInnerHits();
						pfcand.pvAssocQuality = pfcand1->pvAssociationQuality();
						pfcand.trackHighPurity = pfcand1->trackHighPurity();
						pfcand.pixelhits = pfcand1->numberOfPixelHits();
						
						if(pfcand1->bestTrack()){
							const reco::Track *trktrk = pfcand1->bestTrack();
							pfcand.trkChi2 = trktrk->normalizedChi2();
							pfcand.nTrackerLayers = trktrk->hitPattern().trackerLayersWithMeasurement();
						}
	
						//cout<<pfcand1->ptTrk()<<" "<<<endl;
						//cout<<pfcand1->vertexNormalizedChi2()<<"\t"
						//<<pfcand1->vertexNdof()<<"\t"
						//<<pfcand1->rawCaloFraction()<<"\t"
						//<<pfcand1->isIsolatedChargedHadron()<<"\t"
	
					}
					
					pfcandidates.push_back(pfcand);
			
					if (++nPFCand>=nconsmax) break;  
				
				} // DR cond
		
		
			}// loop over pfcands
	
		}
		
		PFCand_pt_rel.clear();
		PFCand_pt_rel_log.clear();
		PFCand_eta_rel.clear();
		PFCand_phi_rel.clear();
		PFCand_phiAtVtx_rel.clear();
		PFCand_deltaR.clear();
		PFCand_puppiWeight.clear();
		PFCand_puppiWeightNoLep.clear();
		PFCand_caloFraction.clear();
		PFCand_hcalFraction.clear();
		PFCand_hcalFractionCalib.clear();
		PFCand_pdgId.clear();
		PFCand_energy_log.clear();
		PFCand_dz.clear();
		PFCand_dzError.clear();
		PFCand_dzSig.clear();
		PFCand_dxy.clear();
		PFCand_dxyError.clear();
		PFCand_dxySig.clear();
		PFCand_trkChi2.clear();
		PFCand_vertexChi2.clear();
		PFCand_charge.clear();
		PFCand_pvAssocQuality.clear();
		PFCand_nTrackerLayers.clear();
		PFCand_pixelhits.clear();
		PFCand_status.clear();
		//PFCand_time.clear();
		PFCand_trackHighPurity.clear();
		PFCand_isElectron.clear();
		PFCand_isMuon.clear();
		PFCand_isChargedHadron.clear();
		PFCand_fromPV.clear();
		/*
		NeutralPFCand_pt_rel.clear();
		NeutralPFCand_eta_rel.clear();
		NeutralPFCand_phi_rel.clear();
		NeutralPFCand_phiAtVtx_rel.clear();
		NeutralPFCand_deltaR.clear();
		NeutralPFCand_puppiWeight.clear();
		NeutralPFCand_puppiWeightNoLep.clear();
		NeutralPFCand_caloFraction.clear();
		NeutralPFCand_hcalFraction.clear();
		NeutralPFCand_hcalFractionCalib.clear();
		NeutralPFCand_pdgId.clear();
		NeutralPFCand_isPhoton.clear();
		NeutralPFCand_isNeutralHadron.clear();
		*/
		
		nChargePFCand = 0;
		nNeutralPFCand = 0;
		
		for(unsigned ipf=0; ipf<pfcandidates.size(); ipf++){
			
			if(delta2R(leptons[ilep].eta,leptons[ilep].phi,pfcandidates[ipf].eta,pfcandidates[ipf].phi)>dRmin) {
			
		//	if(abs(pfcandidates[ipf].charge)>0){
				
		//		if(pfcandidates[ipf].hasTrackDetails){
			
			PFCand_pt_rel.push_back(pfcandidates[ipf].pt/lepton_pt);
			PFCand_pt_rel_log.push_back(log(pfcandidates[ipf].pt/lepton_pt));
			PFCand_eta_rel.push_back(pfcandidates[ipf].eta - lepton_eta);
			PFCand_phi_rel.push_back(PhiInRange(pfcandidates[ipf].phi - lepton_phi));
			PFCand_phiAtVtx_rel.push_back(PhiInRange(pfcandidates[ipf].phiAtVtx - lepton_phi));
			PFCand_deltaR.push_back(delta2R(pfcandidates[ipf].eta,pfcandidates[ipf].phi,lepton_eta,lepton_phi));
			PFCand_puppiWeight.push_back(pfcandidates[ipf].puppiWeight);
			PFCand_puppiWeightNoLep.push_back(pfcandidates[ipf].puppiWeightNoLep);
			PFCand_caloFraction.push_back(pfcandidates[ipf].caloFraction);
			PFCand_hcalFraction.push_back(pfcandidates[ipf].hcalFraction);
			PFCand_hcalFractionCalib.push_back(pfcandidates[ipf].hcalFractionCalib);
			PFCand_pdgId.push_back(float(pfcandidates[ipf].pdgId));
			
			TLorentzVector pfcand_p4;
			pfcand_p4.SetPtEtaPhiM(pfcandidates[ipf].pt,pfcandidates[ipf].eta,pfcandidates[ipf].phi,pfcandidates[ipf].mass);
			PFCand_energy_log.push_back(log(pfcand_p4.E()));
  
			PFCand_dz.push_back(pfcandidates[ipf].dz);
			PFCand_dzError.push_back(pfcandidates[ipf].dzError);
			PFCand_dzSig.push_back(pfcandidates[ipf].dzSig);
			PFCand_dxy.push_back(pfcandidates[ipf].dxy);
			PFCand_dxyError.push_back(pfcandidates[ipf].dxyError);
			PFCand_dxySig.push_back(pfcandidates[ipf].dxySig);
			PFCand_trkChi2.push_back(pfcandidates[ipf].trkChi2);
			PFCand_vertexChi2.push_back(pfcandidates[ipf].vertexChi2);
			PFCand_charge.push_back(float(pfcandidates[ipf].charge));
			PFCand_lostInnerHits.push_back(float(pfcandidates[ipf].lostInnerHits));
			PFCand_pvAssocQuality.push_back(float(pfcandidates[ipf].pvAssocQuality));
			PFCand_nTrackerLayers.push_back(float(pfcandidates[ipf].nTrackerLayers));
			PFCand_pixelhits.push_back(float(pfcandidates[ipf].pixelhits));
			PFCand_status.push_back(float(pfcandidates[ipf].status));
			//PFCand_time.push_back(pfcandidates[ipf].time);
			PFCand_trackHighPurity.push_back(float(pfcandidates[ipf].trackHighPurity));
			PFCand_isElectron.push_back(float(pfcandidates[ipf].isElectron));
			PFCand_isMuon.push_back(float(pfcandidates[ipf].isMuon));
			PFCand_isChargedHadron.push_back(float(pfcandidates[ipf].isChargedHadron));
			PFCand_fromPV.push_back(float(pfcandidates[ipf].fromPV));
			//	}
			//}
			
			if(abs(pfcandidates[ipf].charge)>0){ nChargePFCand++; }
			else { nNeutralPFCand++; }
			
			/*
			else{
			
				NeutralPFCand_pt_rel.push_back(pfcandidates[ipf].pt/lepton_pt);
				NeutralPFCand_eta_rel.push_back(pfcandidates[ipf].eta - lepton_eta);
				NeutralPFCand_phi_rel.push_back(PhiInRange(pfcandidates[ipf].phi - lepton_phi));
				NeutralPFCand_phiAtVtx_rel.push_back(PhiInRange(pfcandidates[ipf].phiAtVtx - lepton_phi));
				NeutralPFCand_deltaR.push_back(delta2R(pfcandidates[ipf].eta,pfcandidates[ipf].phi,lepton_eta,lepton_phi));
				NeutralPFCand_puppiWeight.push_back(pfcandidates[ipf].puppiWeight);
				NeutralPFCand_puppiWeightNoLep.push_back(pfcandidates[ipf].puppiWeightNoLep);
				NeutralPFCand_caloFraction.push_back(pfcandidates[ipf].caloFraction);
				NeutralPFCand_hcalFraction.push_back(pfcandidates[ipf].hcalFraction);
				NeutralPFCand_hcalFractionCalib.push_back(pfcandidates[ipf].hcalFractionCalib);
				NeutralPFCand_pdgId.push_back(pfcandidates[ipf].pdgId);
				NeutralPFCand_isPhoton.push_back(pfcandidates[ipf].isPhoton);
				NeutralPFCand_isNeutralHadron.push_back(pfcandidates[ipf].isNeutralHadron);
				
			}
			*/ 
  
			} // DR condition
  
		}//ipf
		
		
		PFCandplusLep_pt_rel.clear();
		PFCandplusLep_pt_rel_log.clear();
		PFCandplusLep_pt_log.clear();
		PFCandplusLep_eta_rel.clear();
		PFCandplusLep_phiAtVtx_rel.clear();
		PFCandplusLep_deltaR.clear();
		PFCandplusLep_puppiWeight.clear();
		PFCandplusLep_puppiWeightNoLep.clear();
		PFCandplusLep_caloFraction.clear();
		PFCandplusLep_hcalFraction.clear();
		PFCandplusLep_hcalFractionCalib.clear();
		PFCandplusLep_pdgId.clear();
		PFCandplusLep_energy_log.clear();
		PFCandplusLep_dz.clear();
		PFCandplusLep_dzError.clear();
		PFCandplusLep_dzSig.clear();
		PFCandplusLep_dxy.clear();
		PFCandplusLep_dxyError.clear();
		PFCandplusLep_dxySig.clear();
		PFCandplusLep_trkChi2.clear();
		PFCandplusLep_vertexChi2.clear();
		PFCandplusLep_charge.clear();
		PFCandplusLep_pvAssocQuality.clear();
		PFCandplusLep_nTrackerLayers.clear();
		PFCandplusLep_pixelhits.clear();
		PFCandplusLep_status.clear();
		//PFCand_time.clear();
		PFCandplusLep_trackHighPurity.clear();
		PFCandplusLep_isElectron.clear();
		PFCandplusLep_isMuon.clear();
		PFCandplusLep_isChargedHadron.clear();
		PFCandplusLep_fromPV.clear();
		
		for(unsigned ipf=0; ipf<pfcandidates.size(); ipf++){
		
			PFCandplusLep_pt_rel.push_back(pfcandidates[ipf].pt/lepton_pt);
			PFCandplusLep_pt_rel_log.push_back(log(pfcandidates[ipf].pt/lepton_pt));
			PFCandplusLep_pt_log.push_back(log(pfcandidates[ipf].pt));
			PFCandplusLep_eta_rel.push_back(pfcandidates[ipf].eta - lepton_eta);
			PFCandplusLep_phiAtVtx_rel.push_back(PhiInRange(pfcandidates[ipf].phiAtVtx - lepton_phi));
			PFCandplusLep_deltaR.push_back(delta2R(pfcandidates[ipf].eta,pfcandidates[ipf].phi,lepton_eta,lepton_phi));
			PFCandplusLep_puppiWeight.push_back(pfcandidates[ipf].puppiWeight);
			PFCandplusLep_puppiWeightNoLep.push_back(pfcandidates[ipf].puppiWeightNoLep);
			PFCandplusLep_caloFraction.push_back(pfcandidates[ipf].caloFraction);
			PFCandplusLep_hcalFraction.push_back(pfcandidates[ipf].hcalFraction);
			PFCandplusLep_hcalFractionCalib.push_back(pfcandidates[ipf].hcalFractionCalib);
			PFCandplusLep_pdgId.push_back(float(pfcandidates[ipf].pdgId));
			
			TLorentzVector pfcand_p4;
			pfcand_p4.SetPtEtaPhiM(pfcandidates[ipf].pt,pfcandidates[ipf].eta,pfcandidates[ipf].phi,pfcandidates[ipf].mass);
			PFCandplusLep_energy_log.push_back(log(pfcand_p4.E()));
  
			PFCandplusLep_dz.push_back(pfcandidates[ipf].dz);
			PFCandplusLep_dzError.push_back(pfcandidates[ipf].dzError);
			PFCandplusLep_dzSig.push_back(pfcandidates[ipf].dzSig);
			PFCandplusLep_dxy.push_back(pfcandidates[ipf].dxy);
			PFCandplusLep_dxyError.push_back(pfcandidates[ipf].dxyError);
			PFCandplusLep_dxySig.push_back(pfcandidates[ipf].dxySig);
		
			PFCandplusLep_trkChi2.push_back(pfcandidates[ipf].trkChi2);
			PFCandplusLep_vertexChi2.push_back(pfcandidates[ipf].vertexChi2);
			PFCandplusLep_charge.push_back(float(pfcandidates[ipf].charge));
			PFCandplusLep_lostInnerHits.push_back(float(pfcandidates[ipf].lostInnerHits));
			PFCandplusLep_pvAssocQuality.push_back(float(pfcandidates[ipf].pvAssocQuality));
			PFCandplusLep_nTrackerLayers.push_back(float(pfcandidates[ipf].nTrackerLayers));
			PFCandplusLep_pixelhits.push_back(float(pfcandidates[ipf].pixelhits));
			PFCandplusLep_status.push_back(float(pfcandidates[ipf].status));
			//PFCand_time.push_back(pfcandidates[ipf].time);
			PFCandplusLep_trackHighPurity.push_back(float(pfcandidates[ipf].trackHighPurity));
			PFCandplusLep_isElectron.push_back(float(pfcandidates[ipf].isElectron));
			PFCandplusLep_isMuon.push_back(float(pfcandidates[ipf].isMuon));
			PFCandplusLep_isChargedHadron.push_back(float(pfcandidates[ipf].isChargedHadron));
			PFCandplusLep_fromPV.push_back(float(pfcandidates[ipf].fromPV));
			
		} //ipf
		
		// secondary vertices within dR=0.5 //
		
		nSV = 0;
		
		SV_mass.clear(), SV_pt_rel.clear(), SV_pt_rel_log.clear(); 
		SV_deltaR.clear(); SV_eta_rel.clear(); SV_phi_rel.clear(); 
		SV_ndof.clear(); SV_chi2.clear(); SV_ntracks.clear();
		SV_d3d.clear(), SV_d3dError.clear(); SV_d3dSig.clear();
		SV_dxy.clear(); SV_dxyError.clear(); SV_dxySig.clear();
		SV_pAngle.clear(); SV_cospAngle.clear();
		
		for(unsigned int isv=0; isv<(secondaryVertices->size()); isv++){                                                                                        
	
			const auto &sv = (*secondaryVertices)[isv];                                                                                                           
			reco::TrackBase::Point svpoint(sv.vx(),sv.vy(),sv.vz());
	
			float dRmax = DR_SV_Maximum;
		
			if(delta2R(leptons[ilep].eta,leptons[ilep].phi,sv.eta(),sv.phi())<dRmax){
			
				SV_mass.push_back(sv.mass());
				SV_pt_rel.push_back(sv.pt()/lepton_pt);
				SV_pt_rel_log.push_back(log(sv.pt()/lepton_pt));
				SV_eta_rel.push_back(sv.eta()-lepton_eta);
				SV_phi_rel.push_back(PhiInRange(sv.phi()-lepton_phi));
				SV_deltaR.push_back(delta2R(lepton_eta,lepton_phi,sv.eta(),sv.phi()));
				
				SV_ndof.push_back(float(sv.vertexNdof()));
				SV_chi2.push_back(sv.vertexNormalizedChi2());
				SV_ntracks.push_back(float(sv.numberOfDaughters()));
				
				VertexDistance3D vdist;
				Measurement1D dl = vdist.distance(PV_vertex, VertexState(RecoVertex::convertPos(sv.position()), RecoVertex::convertError(sv.error())));
				SV_d3d.push_back(dl.value());
				SV_d3dError.push_back(dl.error());
				SV_d3dSig.push_back(dl.significance());
			
				VertexDistanceXY vdistXY;
				Measurement1D d2d = vdistXY.distance(PV_vertex, VertexState(RecoVertex::convertPos(sv.position()), RecoVertex::convertError(sv.error())));
				SV_dxy.push_back(d2d.value());
				SV_dxyError.push_back(d2d.error());
				SV_dxySig.push_back(d2d.significance());
			
				double dx = (PV_vertex.x() - sv.vx()), dy = (PV_vertex.y() - sv.vy()), dz = (PV_vertex.z() - sv.vz());
				double pdotv = (dx * sv.px() + dy * sv.py() + dz * sv.pz()) / sv.p() / sqrt(dx * dx + dy * dy + dz * dz);
				SV_pAngle.push_back(acos(pdotv));
				SV_cospAngle.push_back(pdotv);
		
				if (++nSV>=nsvmax) break;
				  
			} // DR condition
			
		}// loop over secondary vertices	
		
		// nearest jet //
		
		int i_nearjet = -1;
		float dR_lj_min = DR_AK4Jet_Maximum;
		
		for(int ijet=0; ijet<nPFJetAK4; ijet++){
			if(matchbydR){
				if(delta2R(lepton_eta,lepton_phi,PFJetAK4_eta[ijet],PFJetAK4_phi[ijet])<dR_lj_min){
					dR_lj_min = delta2R(lepton_eta,lepton_phi,PFJetAK4_eta[ijet],PFJetAK4_phi[ijet]);
					i_nearjet = ijet;
				}
			}
			else{
				const auto &ak4jet = (*pfjetAK4s)[PFJetAK4_index[ijet]];
				bool match_found = (abs(lepton_pdgId)==11)?JetMatchByCommonSourceCandidatePtr(leptons[ilep].ElectronPtr,ak4jet):JetMatchByCommonSourceCandidatePtr(leptons[ilep].MuonPtr,ak4jet);
				if(match_found) { i_nearjet = ijet; break; }
			}
		}
				
		if(i_nearjet>=0){
		
			const auto &ak4jet = (*pfjetAK4s)[PFJetAK4_index[i_nearjet]];
			TLorentzVector jet_p4;
			jet_p4.SetPtEtaPhiM(PFJetAK4_pt[i_nearjet],PFJetAK4_eta[i_nearjet],PFJetAK4_phi[i_nearjet],PFJetAK4_mass[i_nearjet]);
			
			TLorentzVector lep_p4;
			lep_p4.SetPtEtaPhiM(lepton_pt,lepton_eta,lepton_phi,lepton_mass);
			jet_p4 -= lep_p4;
						
			// Deriving JEC after lepton subtraction & applying it //			
			double tmprecpt = jet_p4.Pt();
			double total_cor =1;
			Read_JEC(total_cor,tmprecpt,jet_p4.Eta(),Rho,isData,ak4jet,jecL1FastAK4,jecL2RelativeAK4,jecL3AbsoluteAK4,jecL2L3ResidualAK4);  
			jet_p4.SetPtEtaPhiM(total_cor*jet_p4.Pt(),jet_p4.Eta(),jet_p4.Phi(),total_cor*jet_p4.M());
			// end of JEC application //
			
			lepton_jetPtRelv2_abs =  (lep_p4.Vect().Perp(jet_p4.Vect()));
			lepton_jetPtRelv2 = (lep_p4.Vect().Perp(jet_p4.Vect()))*1./lepton_pt;
			lepton_jetPtRelv2_log = log(lepton_jetPtRelv2);
			lepton_jetRelIso = jet_p4.Pt()*1./lepton_pt;
			lepton_jetPtRatio = lepton_pt*1./(jet_p4+lep_p4).Pt();
			lepton_jetbtag = PFJetAK4_btag_DeepFlav[i_nearjet];
			lepton_jetbtag_DeepCSV = PFJetAK4_btag_DeepCSV[i_nearjet];
			
			// some other info as well //
			
			lepton_jethadronflavor = ak4jet.hadronFlavour();
			lepton_jetpartonflavor = ak4jet.partonFlavour();
			lepton_jetnConstituents = (ak4jet.chargedMultiplicity()+ak4jet.neutralMultiplicity());
			
			// counting track multiplicity within jet //
    
			int selectedTrackMult = 0;
			
			for( const auto daughterPtr : ak4jet.daughterPtrVector() ){
		
				const pat::PackedCandidate& daughter = *( (const pat::PackedCandidate*) daughterPtr.get() );
            
				if( daughter.charge() == 0 ) continue;
				if( daughter.fromPV() < 2 ) continue;
				if( delta2R(daughter.eta(), daughter.phi(), lepton_eta, lepton_phi) > 0.4 ) continue;
				if( !daughter.hasTrackDetails() ) continue;

				auto daughterTrack = daughter.pseudoTrack();
			
				if (daughterTrack.pt() > 1 && daughterTrack.hitPattern().numberOfValidHits() >= 8 && daughterTrack.hitPattern().numberOfValidPixelHits() >= 2 
				&& daughterTrack.normalizedChi2() < 5 && fabs(daughterTrack.dxy(PV_vertex.position())) < 0.2 && fabs(daughterTrack.dz(PV_vertex.position())) < 17)
				{
					++selectedTrackMult;
				}

			} 
     
			lepton_jetNDauCharged = selectedTrackMult;
			
		}
		else{
			
			lepton_jetPtRelv2_abs = 0;
			lepton_jetPtRelv2 = 0;
			lepton_jetPtRelv2_log = -100;
			
			if(abs(lepton_pdgId)==11){  lepton_jetRelIso = lepton_pfRelIso04_eacor; }
			else if (abs(lepton_pdgId)==13){ lepton_jetRelIso = lepton_pfRelIso04_drcor; }
			else{ lepton_jetRelIso = -100; }
			
			lepton_jetPtRatio = 1./(1.+lepton_jetRelIso);
			lepton_jetbtag = 0;
			lepton_jetbtag_DeepCSV = 0;
			
			lepton_jetNDauCharged = 0;
			
		}
		
		DMatrixHandle dtest, dtestv2;
		int nfeat = 13;				
		
		if(abs(lepton_pdgId)==11){
			
			boosterVars[1][0][0] = lepton_pt;
			boosterVars[1][0][1] = lepton_eta;
			boosterVars[1][0][2] = 1.*lepton_jetNDauCharged;
			boosterVars[1][0][3] = lepton_minchiso;
			boosterVars[1][0][4] = (lepton_minisoall-lepton_minchiso);
			boosterVars[1][0][5] = lepton_jetPtRelv2_abs;
			boosterVars[1][0][6] = lepton_jetPtRatio;
			boosterVars[1][0][7] = lepton_pfRelIso03_drcor;
			boosterVars[1][0][8] = lepton_jetbtag;
			boosterVars[1][0][9] = lepton_sip3d;
			boosterVars[1][0][10] = log(abs(lepton_dxy));
			boosterVars[1][0][11] = log(abs(lepton_dz));
			boosterVars[1][0][12] = lepton_mvaFall17V2noIso;
			boosterVars[1][0][13] = 1.*lepton_lostHits;
		
			XGDMatrixCreateFromMat(reinterpret_cast<float*>(boosterVars[1]), 1, nfeat, NAN, &dtest);
			bst_ulong out_len;
			const float *out_result;
			XGBoosterPredict(booster[1], dtest, 0, 0, &out_len, &out_result); 
			XGDMatrixFree(dtest);
			lepton_TopMVAScore = out_result[0];
			
			XGDMatrixCreateFromMat(reinterpret_cast<float*>(boosterVars[1]), 1, nfeat+1, NAN, &dtestv2);
			bst_ulong out_lenv2;
			const float *out_resultv2;
			XGBoosterPredict(boosterv2[1], dtestv2, 0, 0, &out_lenv2, &out_resultv2); 
			XGDMatrixFree(dtestv2);
			lepton_Topv2MVAScore = out_resultv2[0];
			
		}
		else if (abs(lepton_pdgId)==13){

			boosterVars[0][0][0] = lepton_pt;
			boosterVars[0][0][1] = lepton_eta;
			boosterVars[0][0][2] = 1.*lepton_jetNDauCharged;
			boosterVars[0][0][3] = lepton_minchiso;
			boosterVars[0][0][4] = (lepton_minisoall-lepton_minchiso);
			boosterVars[0][0][5] = lepton_jetPtRelv2_abs;
			boosterVars[0][0][6] = lepton_jetPtRatio;
			boosterVars[0][0][7] = lepton_pfRelIso03_drcor;
			boosterVars[0][0][8] = lepton_jetbtag;
			boosterVars[0][0][9] = lepton_sip3d;
			boosterVars[0][0][10] = log(abs(lepton_dxy));
			boosterVars[0][0][11] = log(abs(lepton_dz));
			boosterVars[0][0][12] = lepton_segmentComp;
			
			XGDMatrixCreateFromMat(reinterpret_cast<float*>(boosterVars[0]), 1, nfeat, NAN, &dtest);
			bst_ulong out_len;
			const float *out_result;
			XGBoosterPredict(booster[0], dtest, 0, 0, &out_len, &out_result); 
			XGDMatrixFree(dtest);
			lepton_TopMVAScore = out_result[0];
			
			XGDMatrixCreateFromMat(reinterpret_cast<float*>(boosterVars[0]), 1, nfeat, NAN, &dtestv2);
			bst_ulong out_lenv2;
			const float *out_resultv2;
			XGBoosterPredict(boosterv2[0], dtestv2, 0, 0, &out_lenv2, &out_resultv2); 
			XGDMatrixFree(dtestv2);
			lepton_Topv2MVAScore = out_resultv2[0];
			
		}
				
		T1->Fill();
		
	} // ilep

  } // nLepton>=1 
  
  // End of skimming 
  
}
